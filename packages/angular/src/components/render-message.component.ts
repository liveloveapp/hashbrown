/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @angular-eslint/component-selector */
import {
  ApplicationRef,
  Component,
  computed,
  EmbeddedViewRef,
  inject,
  input,
  TemplateRef,
  ViewContainerRef,
} from '@angular/core';
import { NgComponentOutlet, NgTemplateOutlet } from '@angular/common';
import {
  getTagNameRegistry,
  UiAssistantMessage,
  UiChatSchema,
  UiChatSchemaComponent,
} from '../utils';
import type { UiKit } from '../utils/ui-kit.fn';

/**
 * Renders messages generated by the assistant from uiChatResource.
 *
 * @public
 * @example
 *
 * ```html
 * <hb-render-message [message]="message" />
 * <hb-render-message [ui]="ui" [uiKit]="uiKit" />
 * ```
 */
@Component({
  selector: 'hb-render-message',
  imports: [NgComponentOutlet, NgTemplateOutlet],
  template: `
    <ng-template #nodeTemplateRef let-node="node">
      <ng-template #childrenTemplateRef>
        @if (isTextNode(node)) {
          {{ getTextChildren(node) }}
        } @else {
          @for (child of getChildrenArray(node); track $index) {
            <ng-container
              *ngTemplateOutlet="nodeTemplateRef; context: { node: child }"
            />
          }
        }
      </ng-template>

      @if (node) {
        <ng-container
          *ngComponentOutlet="
            getRenderableComponent(node);
            inputs: getRenderableInputs(node);
            content: getRenderableContent(node, childrenTemplateRef)
          "
        ></ng-container>
      }
    </ng-template>

    @if (content()) {
      @for (node of content(); track $index) {
        <ng-template
          [ngTemplateOutlet]="nodeTemplateRef"
          [ngTemplateOutletContext]="node"
        >
        </ng-template>
        <ng-container
          *ngTemplateOutlet="nodeTemplateRef; context: { node: node }"
        />
      }
    }
  `,
})
export class RenderMessageComponent {
  message = input<UiAssistantMessage<any> | null>(null);
  ui = input<UiChatSchema | null>(null);
  uiKit = input<UiKit<any> | null>(null);
  /**
   * @internal
   */
  appRef = inject(ApplicationRef);

  /**
   * @internal
   */
  content = computed(() => {
    const { message, ui, uiKit } = this.getRenderInputs();
    if (message) {
      return message.content?.ui ?? [];
    }
    if (ui && uiKit) {
      return ui.ui ?? [];
    }
    return [];
  });

  /**
   * @internal
   */
  tagNameRegistry = computed(() => {
    const { message, ui, uiKit } = this.getRenderInputs();
    if (message) {
      return getTagNameRegistry(message) ?? {};
    }
    if (ui) {
      return uiKit?.tagNameRegistry ?? {};
    }
    return {};
  });

  /**
   * @internal
   */
  viewContainerRef = inject(ViewContainerRef);

  /**
   * @internal
   */
  rootNodesWeakMap = new WeakMap<TemplateRef<any>, any[]>();

  /**
   * @internal
   */
  embeddedViewsWeakMap = new WeakMap<TemplateRef<any>, EmbeddedViewRef<any>>();

  /**
   * @internal
   */
  nodeEntryWeakMap = new WeakMap<object, { tag: string; value: any } | null>();

  /**
   * @internal
   */
  renderableComponentWeakMap = new WeakMap<object, any>();

  /**
   * @internal
   */
  renderableInputsWeakMap = new WeakMap<object, any>();

  /**
   * @internal
   */
  renderableContentWeakMap = new WeakMap<
    object,
    WeakMap<TemplateRef<any>, any[][] | undefined>
  >();

  /**
   * @internal
   */
  static readonly EMPTY_CHILDREN: UiChatSchemaComponent[] = [];

  /**
   * @internal
   */
  getTagComponent(tagName: string) {
    return this.tagNameRegistry()?.[tagName]?.component ?? null;
  }

  /**
   * @internal
   */
  getFallbackComponent(tagName: string) {
    return this.tagNameRegistry()?.[tagName]?.fallback ?? null;
  }

  /**
   * @internal
   */
  getNodeEntry(node: UiChatSchemaComponent) {
    if (!node || typeof node !== 'object') {
      return null;
    }
    if (this.nodeEntryWeakMap.has(node as object)) {
      return this.nodeEntryWeakMap.get(node as object)!;
    }
    const entries = Object.entries(node ?? {});
    if (entries.length === 0) {
      this.nodeEntryWeakMap.set(node as object, null);
      return null;
    }
    const [tag, value] = entries[0] as [string, any];
    const entry = { tag, value };
    this.nodeEntryWeakMap.set(node as object, entry);
    return entry;
  }

  /**
   * @internal
   */
  getNodeChildren(node: UiChatSchemaComponent) {
    return this.getNodeEntry(node)?.value?.children;
  }

  /**
   * @internal
   */
  getChildrenArray(node: UiChatSchemaComponent) {
    const children = this.getNodeChildren(node);
    return Array.isArray(children)
      ? children
      : RenderMessageComponent.EMPTY_CHILDREN;
  }

  /**
   * @internal
   */
  getTextChildren(node: UiChatSchemaComponent) {
    const children = this.getNodeChildren(node);
    return typeof children === 'string' ? children : '';
  }

  /**
   * @internal
   */
  getRenderableComponent(node: UiChatSchemaComponent) {
    if (node && typeof node === 'object') {
      if (this.renderableComponentWeakMap.has(node as object)) {
        return this.renderableComponentWeakMap.get(node as object)!;
      }
    }
    const entry = this.getNodeEntry(node);
    if (!entry) {
      return null;
    }
    const propsNode = entry.value?.props;
    if (!propsNode) {
      return null;
    }
    if (!propsNode.value) {
      const fallback = this.getFallbackComponent(entry.tag);
      if (node && typeof node === 'object') {
        this.renderableComponentWeakMap.set(node as object, fallback);
      }
      return fallback;
    }
    const component = this.getTagComponent(entry.tag);
    if (node && typeof node === 'object') {
      this.renderableComponentWeakMap.set(node as object, component);
    }
    return component;
  }

  /**
   * @internal
   */
  getRenderableInputs(node: UiChatSchemaComponent) {
    if (node && typeof node === 'object') {
      if (this.renderableInputsWeakMap.has(node as object)) {
        return this.renderableInputsWeakMap.get(node as object)!;
      }
    }
    const entry = this.getNodeEntry(node);
    if (!entry) {
      return null;
    }
    const propsNode = entry.value?.props;
    if (!propsNode) {
      return null;
    }
    if (!propsNode.value) {
      const fallback = this.getFallbackComponent(entry.tag);
      if (!fallback) {
        return null;
      }
      const inputs = {
        partialProps: propsNode.partialValue as Record<string, any>,
      };
      if (node && typeof node === 'object') {
        this.renderableInputsWeakMap.set(node as object, inputs);
      }
      return inputs;
    }
    if (node && typeof node === 'object') {
      this.renderableInputsWeakMap.set(node as object, propsNode.value);
    }
    return propsNode.value;
  }

  /**
   * @internal
   */
  getRenderableContent(
    node: UiChatSchemaComponent,
    tpl: TemplateRef<any>,
  ): any[][] | undefined {
    if (node && typeof node === 'object') {
      const existing = this.renderableContentWeakMap.get(node as object);
      if (existing && existing.has(tpl)) {
        return existing.get(tpl);
      }
    }
    const entry = this.getNodeEntry(node);
    if (!entry) {
      return undefined;
    }
    const propsNode = entry.value?.props;
    if (!propsNode?.value) {
      return undefined;
    }
    if (!('children' in (entry.value ?? {}))) {
      return undefined;
    }
    const content = this.getRootNodes(tpl);
    if (node && typeof node === 'object') {
      let cache = this.renderableContentWeakMap.get(node as object);
      if (!cache) {
        cache = new WeakMap<TemplateRef<any>, any[][] | undefined>();
        this.renderableContentWeakMap.set(node as object, cache);
      }
      cache.set(tpl, content);
    }
    return content;
  }

  /**
   * @internal
   */
  getEmbeddedView(tpl: TemplateRef<any>) {
    if (this.embeddedViewsWeakMap.has(tpl)) {
      return this.embeddedViewsWeakMap.get(tpl)!;
    }

    const view = this.viewContainerRef.createEmbeddedView(tpl);
    this.embeddedViewsWeakMap.set(tpl, view);
    return view;
  }

  /**
   * @internal
   */
  getRootNodes(tpl: TemplateRef<any>) {
    if (this.rootNodesWeakMap.has(tpl)) {
      return this.rootNodesWeakMap.get(tpl)!;
    }

    const view = this.getEmbeddedView(tpl);
    const nodes = [view.rootNodes];
    this.rootNodesWeakMap.set(tpl, nodes);
    return nodes;
  }

  /**
   * @internal
   */
  isRenderableComplete(node: UiChatSchemaComponent): boolean {
    if (!node || typeof node !== 'object') {
      return false;
    }

    const entry = this.getNodeEntry(node);
    if (!entry) {
      return false;
    }

    const value = entry.value as
      | {
          props?: { value?: Record<string, unknown> };
          children?: UiChatSchemaComponent[] | string;
        }
      | undefined;

    if (!value?.props?.value) {
      return false;
    }

    if (typeof value.children === 'string' || value.children === undefined) {
      return true;
    }

    return value.children.every((child) => this.isRenderableComplete(child));
  }

  /**
   * @internal
   */
  isTextNode(node: UiChatSchemaComponent) {
    return typeof this.getNodeChildren(node) === 'string';
  }

  private getRenderInputs() {
    const message = this.message();
    const ui = this.ui();
    const uiKit = this.uiKit();

    if (message && ui) {
      throw new Error(
        'hb-render-message accepts either "message" or "ui", but not both.',
      );
    }

    if (ui && !uiKit) {
      throw new Error(
        'hb-render-message requires "uiKit" when rendering a UI wrapper.',
      );
    }

    if (ui && uiKit) {
      const nodes = ui.ui ?? [];
      const isComplete = nodes.every((node) => this.isRenderableComplete(node));
      if (isComplete) {
        uiKit.schema.validate(ui);
      }
    }

    return { message, ui, uiKit };
  }
}
