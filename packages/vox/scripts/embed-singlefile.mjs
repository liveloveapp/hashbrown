#!/usr/bin/env node

/**
 * Embed the VAD worklet assets into a single JS loader.
 *
 * Inputs (must exist before running):
 *   dist/packages/vox/assets/vad_audio_worklet.js
 *   dist/packages/vox/assets/vad_audio_worklet.aw.js
 *   dist/packages/vox/assets/vad_audio_worklet.ww.js
 *   dist/packages/vox/assets/vad_audio_worklet.wasm
 *
 * Output:
 *   dist/packages/vox/assets/vad_audio_worklet.single.js
 *
 * The generated file exports a default async function that mirrors the
 * original module factory but inlines the WASM and worklet scripts via
 * data/blob URLs, so no extra network fetches are needed.
 */

import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import url from 'url';

const __dirname = url.fileURLToPath(new URL('.', import.meta.url));
// dist root: repo/dist/packages/vox (script lives in packages/vox/scripts)
const distRoot = join(__dirname, '..', '..', '..', 'dist', 'packages', 'vox');
const distAssets = join(distRoot, 'assets');
const srcRoot = join(__dirname, '..', 'src');
const sourceRoot = distAssets; // use locally built assets in dist
const asset = (root, name) => join(root, name);

const files = {
  loader: join(sourceRoot, 'vad_audio_worklet.js'),
  aw: join(sourceRoot, 'vad_audio_worklet.aw.js'),
  ww: join(sourceRoot, 'vad_audio_worklet.ww.js'),
  wasm: join(sourceRoot, 'vad_audio_worklet.wasm'),
};

function toBase64(path) {
  return readFileSync(path).toString('base64');
}

function readText(path) {
  return readFileSync(path, 'utf8');
}

const wasmBase64 = toBase64(files.wasm);
const awSource = readText(files.aw);
const wwSource = readText(files.ww);
const loaderSource = readText(files.loader);

const outPathDist = asset(distAssets, 'vad_audio_worklet.single.js');
const outPathSrc = asset(srcRoot, 'assets/vad_audio_worklet.single.js');

const result = `// Auto-generated single-file loader with embedded WASM and worklet scripts.
// Generated by scripts/embed-singlefile.mjs
import baseFactory from './vad_audio_worklet.js';

const wasmBase64 = '${wasmBase64}';
const awSource = ${JSON.stringify(awSource)};
const wwSource = ${JSON.stringify(wwSource)};

let awUrl = null;
let wwUrl = null;

function ensureWorkletUrls() {
  if (!awUrl) {
    awUrl = URL.createObjectURL(new Blob([awSource], { type: 'application/javascript' }));
  }
  if (!wwUrl) {
    wwUrl = URL.createObjectURL(new Blob([wwSource], { type: 'application/javascript' }));
  }
  return { awUrl, wwUrl };
}

function decodeWasm() {
  const binaryString = atob(wasmBase64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

export default async function createEmbeddedModule(options = {}) {
  const wasmBinary = decodeWasm();
  const { awUrl, wwUrl } = ensureWorkletUrls();

  const merged = {
    ...options,
    wasmBinary,
    locateFile: (path) => {
      if (options.locateFile) return options.locateFile(path);
      if (path.endsWith('.wasm')) {
        return 'data:application/wasm;base64,' + wasmBase64;
      }
      if (path.endsWith('.aw.js')) return awUrl;
      if (path.endsWith('.ww.js')) return wwUrl;
      return path;
    },
    mainScriptUrlOrBlob:
      options.mainScriptUrlOrBlob ??
      // point back to the embedded loader itself
      new URL('./vad_audio_worklet.single.js', import.meta.url).href,
  };

  return baseFactory(merged);
}
`;

writeFileSync(outPathDist, result);
writeFileSync(outPathSrc, result);
console.log(`Embedded loader written to ${outPathDist}`);
console.log(`Embedded loader copied to ${outPathSrc} for dev path resolution`);
