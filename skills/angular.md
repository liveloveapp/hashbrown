Angular playbook for LLM agents

- Setup: Target Node 20.19+; use Angular CLI (`ng`) for projects and schematics. Keep app code under `src/` with `main.ts` as the entry; co-locate template/style/test files (`*.html`, `*.css`, `*.spec.ts`) named with dash-case matching the class.
- Naming & structure: One primary concept per file; keep related component assets in the same folder. Prefer feature-oriented folders over type-based buckets. Stay consistent with existing file/style patterns.
- Selectors: One component per element; selectors are case-sensitive. Prefer custom elements with hyphen and short project prefix (avoid `ng-`). Attribute selectors use lower dash-case. Avoid collisions with native element properties.
- Components/directives: Prefer standalone components. Group Angular API members (injects, inputs/models/outputs, queries) before methods. Keep components presentation-focused; move logic to helpers/services. Keep lifecycle hooks thin and implement their interfaces.
- Dependency injection: Prefer `inject()` over constructor params for readability and type inference. Understand provider scope (`providers` vs `viewProviders`) and resolution modifiers (`optional`, `self`, `skipSelf`, `host`). Use lightweight injection tokens for tree-shakable APIs when possible.
- State & signals: Use signals/computed/effect for reactivity; `linkedSignal` for derived-but-overridable state. Use resources/httpResource for async data with cancellation and status handling. Convert between signals and RxJS with `toSignal`/`toObservable` as needed.
- Inputs/outputs/models: Default to signal-based APIs: `input()` (optionally required/default/transform/alias), `model()` for two-way bindings (auto `XChange` output), and `output()` for events. Mark Angular-managed props as `readonly`; mark template-only members `protected`. Name handlers for what they do (`saveUser`), not the event (`handleClick`). Prefer input transforms over setters; alias sparingly.
- Templates: Use interpolation for text, property bindings for DOM/component properties, and differentiate attributes vs properties consciously. Prefer `[class]`/`[style]` over `ngClass`/`ngStyle`. Keep template logic simple; push complexity into TypeScript/computed signals.
- Control flow & templating: Use `@if/@else-if/@else`, `@for` (always set `track`), `@switch`, `@let` for locals, and template refs for DOM access. Use `@defer` with `@placeholder/@loading/@error` for optimistic/lazy UI; avoid nested cascades that cause jank.
- Styling & encapsulation: Place styles inline or in `styleUrl`; default ViewEncapsulation.Emulated. Use ShadowDom/ExperimentalIsolatedShadowDom when strict scoping is required; use `None` only for intentional globals. Avoid new `::ng-deep` usage. Prefer class hooks over element-matching where possible.
- Inputs/models/outputs naming: Avoid prefixes on inputs; avoid clashes with HTMLElement properties. Outputs/events describe the result (`saved`, `closed`). Two-way bindings use banana-in-a-box `[(value)]` on model inputs or plain properties.
- Content projection: Use `<ng-content>` slots; support multiple projections via `select`; provide reasonable fallback content and aliases when needed.
- Routing: Define routes with `provideRouter` (or module equivalent); use `router-outlet`, `RouterLink`, `router.navigate*`. Support params/query/matrix data; use resolvers/route data and route-level providers for DI where useful. Prefer lazy loading for features.
- HTTP & services: Provide services with `@Injectable`; favor HttpClient with interceptors (auth, logging, caching). Handle errors/timeouts and use appropriate response types. Configure XSRF/JSONP/fetch options via `provideHttpClient` features.
- Forms: Prefer reactive/typed forms for complex flows; keep controls strongly typed. Use validators (sync/async) and surface status via CSS classes. For template-driven, use `ngModel` cautiously; track validity states and error messaging.
- Testing: Use Angular TestBed/Vitest setup; harnesses for DOM interaction; spy or override providers for isolation. Cover inputs/outputs, async behaviors, and routing. Keep tests close to code.
- Rendering modes: Know SPA vs SSR vs hybrid; enable hydration carefully (avoid direct DOM mutations before stabilization). Use incremental hydration triggers (`hydrate on/when/never`) when splitting work.
- Performance & accessibility: Track items in `@for`, avoid expensive setters and DOM mutation in change detection. Prefer `class`/`style` bindings for perf. Use ARIA attributes appropriately; leverage NgOptimizedImage for responsive images. Avoid direct DOM manipulation unless necessary; if used, ensure hydration and zone considerations are handled.
- Animations: Prefer CSS/modern View Transitions or `animate.enter/leave`; keep animations optional/fallback-friendly. Avoid reliance on the legacy animations package unless required.
- Security: Avoid bypassing Angular sanitization; be cautious with dynamic HTML. Configure HttpClient XSRF, use `withRequestsMadeViaParent` where needed for nested environments.
- Staying current: Follow Angular release notes; use CLIs/migrations to adopt new patterns (signals, zoneless, etc.). Keep dependencies updated and lint/tests green.
