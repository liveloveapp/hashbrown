#!/usr/bin/env node

/**
 * Embed the VAD worklet assets into a single JS loader.
 *
 * Inputs (must exist before running):
 *   ../bin/vad-audio-worklet/vad_audio_worklet.js
 *   ../bin/vad-audio-worklet/vad_audio_worklet.aw.js
 *   ../bin/vad-audio-worklet/vad_audio_worklet.ww.js
 *   ../bin/vad-audio-worklet/vad_audio_worklet.wasm
 *
 * Output:
 *   ../bin/vad-audio-worklet/vad_audio_worklet.single.js
 *   ../../packages/vox/src/assets/vad_audio_worklet.single.js
 *
 * Also copies:
 *   ../../packages/vox/src/assets/vad_audio_worklet.js -> ../bin/vad-audio-worklet/
 *
 * The generated file exports a default async function that mirrors the
 * original module factory but inlines the WASM and worklet scripts via
 * data/blob URLs, so no extra network fetches are needed.
 */

import { readFileSync, writeFileSync, copyFileSync } from 'fs';
import { join } from 'path';
import url from 'url';

const __dirname = url.fileURLToPath(new URL('.', import.meta.url));
// Script lives in wasm/vad-audio-worklet/
const binDir = join(__dirname, '..', 'bin', 'vad-audio-worklet');
const voxAssetsDir = join(__dirname, '..', '..', 'packages', 'vox', 'src', 'assets');
const voxLoaderPath = join(voxAssetsDir, 'vad_audio_worklet.js');

const files = {
  loader: voxLoaderPath, // Read from vox assets, will copy to bin later
  aw: join(binDir, 'vad_audio_worklet.aw.js'),
  ww: join(binDir, 'vad_audio_worklet.ww.js'),
  wasm: join(binDir, 'vad_audio_worklet.wasm'),
};

function toBase64(path) {
  return readFileSync(path).toString('base64');
}

function readText(path) {
  return readFileSync(path, 'utf8');
}

const wasmBase64 = toBase64(files.wasm);
const awSource = readText(files.aw);
const wwSource = readText(files.ww);
const loaderSource = readText(files.loader);

const outPathBin = join(binDir, 'vad_audio_worklet.single.js');
const outPathVoxAssets = join(voxAssetsDir, 'vad_audio_worklet.single.js');

const result = `// Auto-generated single-file loader with embedded WASM and worklet scripts.
// Generated by wasm/vad-audio-worklet/embed-singlefile.mjs
import baseFactory from './vad_audio_worklet.js';

const wasmBase64 = '${wasmBase64}';
const awSource = ${JSON.stringify(awSource)};
const wwSource = ${JSON.stringify(wwSource)};

let awUrl = null;
let wwUrl = null;

function ensureWorkletUrls() {
  if (!awUrl) {
    awUrl = URL.createObjectURL(new Blob([awSource], { type: 'application/javascript' }));
  }
  if (!wwUrl) {
    wwUrl = URL.createObjectURL(new Blob([wwSource], { type: 'application/javascript' }));
  }
  return { awUrl, wwUrl };
}

function decodeWasm() {
  const binaryString = atob(wasmBase64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

export default async function createEmbeddedModule(options = {}) {
  const wasmBinary = decodeWasm();
  const { awUrl, wwUrl } = ensureWorkletUrls();

  const merged = {
    ...options,
    wasmBinary,
    locateFile: (path) => {
      if (options.locateFile) return options.locateFile(path);
      if (path.endsWith('.wasm')) {
        return 'data:application/wasm;base64,' + wasmBase64;
      }
      if (path.endsWith('.aw.js')) return awUrl;
      if (path.endsWith('.ww.js')) return wwUrl;
      return path;
    },
    mainScriptUrlOrBlob:
      options.mainScriptUrlOrBlob ??
      // point back to the embedded loader itself
      new URL('./vad_audio_worklet.single.js', import.meta.url).href,
  };

  return baseFactory(merged);
}
`;

// Write singlefile to both locations
writeFileSync(outPathBin, result);
writeFileSync(outPathVoxAssets, result);
console.log(`Embedded loader written to ${outPathBin}`);
console.log(`Embedded loader written to ${outPathVoxAssets}`);

// Copy the loader from vox assets to bin directory
copyFileSync(voxLoaderPath, join(binDir, 'vad_audio_worklet.js'));
console.log(`Copied loader from ${voxLoaderPath} to ${join(binDir, 'vad_audio_worklet.js')}`);

